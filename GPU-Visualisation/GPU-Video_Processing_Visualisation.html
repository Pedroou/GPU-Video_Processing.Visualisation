<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>GPU Architecture for AI Video Processing</title>
        <script src="https://cdn.tailwindcss.com"></script>
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link
            href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
            rel="stylesheet"
        />
        <style>
            body {
                font-family: "Inter", sans-serif;
            }

            /* Grid class */
            .grid-cols-25 {
                grid-template-columns: repeat(25, minmax(0, 1fr));
            }

            /* CUDA Core Styles */
            .cuda-core {
                width: 10px;
                height: 10px;
                background-color: #14b8a6;
                opacity: 0.6;
                border-radius: 2px;
                transition: all 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
                transform-origin: center;
                will-change: transform, opacity, box-shadow;
                position: relative;
            }

            .cuda-core.highlight {
                background: linear-gradient(135deg, #5eead4, #14b8a6);
                opacity: 1;
                transform: scale(1.3) rotate(5deg);
                box-shadow:
                    0 0 12px #5eead4,
                    0 0 24px rgba(94, 234, 212, 0.4),
                    inset 0 1px 2px rgba(255, 255, 255, 0.3);
                border-radius: 3px;
                z-index: 1;
            }

            /* NVDEC Styles */
            .nvdec-block {
                transition: all 0.8s cubic-bezier(0.23, 1, 0.32, 1);
                border: 2px solid #6366f1;
                position: relative;
                overflow: hidden;
                will-change: transform, box-shadow, background;
                cursor: pointer;
                z-index: 20;
            }

            .nvdec-block::before {
                content: "";
                position: absolute;
                top: 0;
                left: -100%;
                width: 100%;
                height: 100%;
                background: linear-gradient(
                    90deg,
                    transparent,
                    rgba(139, 92, 246, 0.3),
                    transparent
                );
                transition: left 0.8s cubic-bezier(0.23, 1, 0.32, 1);
                pointer-events: none;
            }

            .nvdec-block.highlight {
                background: linear-gradient(135deg, #4f46e5, #6366f1);
                transform: scale(1.08) translateZ(0);
                box-shadow:
                    0 10px 30px rgba(79, 70, 229, 0.4),
                    0 0 20px rgba(99, 102, 241, 0.6),
                    inset 0 1px 4px rgba(255, 255, 255, 0.2);
                border-color: #8b5cf6;
            }

            .nvdec-block.highlight::before {
                left: 100%;
            }

            /* PCIe Connector Styles */
            .pcie-connector {
                transition: all 0.8s cubic-bezier(0.23, 1, 0.32, 1);
                position: absolute;
                overflow: hidden;
                will-change: transform, box-shadow, background;
                cursor: pointer;
                border: 2px solid #b45309;
                background: linear-gradient(
                    180deg,
                    #92400e 0%,
                    #78350f 50%,
                    #451a03 100%
                );
                border-radius: 4px;
                box-shadow:
                    inset 0 1px 0 rgba(251, 191, 36, 0.3),
                    0 2px 4px rgba(0, 0, 0, 0.3);
                z-index: 20;
            }

            .pcie-connector::before {
                content: "";
                position: absolute;
                top: 3px;
                left: 3px;
                right: 3px;
                bottom: 3px;
                background: repeating-linear-gradient(
                    90deg,
                    #fbbf24 0px,
                    #fbbf24 3px,
                    #92400e 3px,
                    #92400e 8px
                );
                border-radius: 2px;
                opacity: 0.8;
                transition: all 0.8s ease;
                pointer-events: none;
            }

            .pcie-connector::after {
                content: "";
                position: absolute;
                top: 0;
                left: -100%;
                width: 100%;
                height: 100%;
                background: linear-gradient(
                    90deg,
                    transparent,
                    rgba(251, 191, 36, 0.4),
                    transparent
                );
                transition: left 0.8s cubic-bezier(0.23, 1, 0.32, 1);
                pointer-events: none;
            }

            .pcie-connector.highlight {
                background: linear-gradient(
                    180deg,
                    #f59e0b 0%,
                    #d97706 50%,
                    #92400e 100%
                );
                transform: scale(1.05) translateZ(0);
                box-shadow:
                    0 8px 25px rgba(217, 119, 6, 0.5),
                    0 0 20px rgba(251, 191, 36, 0.7),
                    inset 0 1px 4px rgba(255, 255, 255, 0.3),
                    inset 0 -1px 4px rgba(0, 0, 0, 0.2);
                border-color: #fbbf24;
                z-index: 21;
            }

            .pcie-connector.highlight::before {
                opacity: 1;
                background: repeating-linear-gradient(
                    90deg,
                    #fde047 0px,
                    #fde047 3px,
                    #f59e0b 3px,
                    #f59e0b 8px
                );
            }

            .pcie-connector.highlight::after {
                left: 100%;
            }

            /* CUDA Section Clickable */
            #cuda-section {
                cursor: pointer;
                position: relative;
                z-index: 20;
                transform-origin: center;
            }

            /* Fade effect */
            .component-fade {
                opacity: 0.15;
                transform: scale(0.96) translateZ(0);
                filter: blur(1px);
                transition: all 0.8s cubic-bezier(0.23, 1, 0.32, 1);
            }

            /* GPU Visual Styles */
            .gpu-pcb {
                background-color: #1a202c;
                border-bottom: 13px solid #718096;
            }
            .io-bracket {
                background: linear-gradient(#718096, #4a5568);
            }
            .fan-shroud {
                background: #2d3748;
                border: 1px solid #4a5568;
            }
            .fan {
                background: #1a202c;
                border: 2px solid #4a5568;
            }
            .fan-spinner {
                width: 100%;
                height: 100%;
                position: relative;
                --fan-duration: 2s;
                animation: spin var(--fan-duration) linear infinite;
                transition: --fan-duration 0.5s ease;
            }
            .fan-spinner::before,
            .fan-spinner::after {
                content: "";
                position: absolute;
                background-color: #718096;
                border-radius: 2px;
            }
            .fan-spinner::before {
                width: 80%;
                height: 4px;
                left: 10%;
                top: 50%;
                transform: translateY(-50%);
            }
            .fan-spinner::after {
                width: 4px;
                height: 80%;
                top: 10%;
                left: 50%;
                transform: translateX(-50%);
            }

            @keyframes spin {
                from {
                    transform: rotate(0deg);
                }
                to {
                    transform: rotate(360deg);
                }
            }

            /* Data Path Visualization Styles */
            .path-overlay {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                z-index: 1;
            }

            .path-line {
                position: absolute;
                background: linear-gradient(90deg, #06b6d4, #0891b2, #0e7490);
                box-shadow: 
                    0 0 8px rgba(6, 182, 212, 0.6),
                    0 0 16px rgba(6, 182, 212, 0.3);
                opacity: 0;
                border-radius: 2px;
                z-index: 1;
            }

            .path-line.horizontal {
                height: 3px;
                transform: scaleX(0);
                transform-origin: left;
                transition: transform 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.4s ease;
            }

            .path-line.vertical {
                width: 3px;
                transform: scaleY(0);
                transform-origin: top;
                transition: transform 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.4s ease;
            }

            .path-line.horizontal.reverse {
                transform-origin: right;
            }

            .path-line.vertical.reverse {
                transform-origin: bottom;
            }

            .path-line.animate {
                opacity: 1;
            }

            .path-line.horizontal.animate {
                transform: scaleX(1);
            }

            .path-line.vertical.animate {
                transform: scaleY(1);
            }

            .path-line.hidden-under-component {
                opacity: 0 !important;
                visibility: hidden !important;
            }

            /* Button styles */
            button {
                transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
                transform: translateZ(0);
            }

            button:hover {
                transform: translateY(-2px) scale(1.02);
                box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            }

            button:active {
                transform: translateY(0) scale(0.98);
            }

            /* Explanation box transitions */
            #explanation-box {
                transition: all 0.5s cubic-bezier(0.23, 1, 0.32, 1);
            }

            /* Hover effects for interactive components */
            #cuda-section:hover {
                transform: scale(1.02);
                box-shadow: 0 4px 12px rgba(20, 184, 166, 0.2);
            }

            .nvdec-block:hover {
                transform: scale(1.02);
                box-shadow: 0 4px 12px rgba(99, 102, 241, 0.2);
            }

            .pcie-connector:hover {
                transform: scale(1.02);
                box-shadow: 0 4px 12px rgba(217, 119, 6, 0.3);
            }
        </style>
    </head>
    <body class="bg-gray-900 text-white">
        <div class="container mx-auto px-4 py-8 md:py-12">
            <header class="text-center mb-8">
                <h1 class="text-3xl md:text-4xl font-bold text-gray-100">
                    Visualizing a GPU for AI Video Processing
                </h1>
                <p class="text-lg text-gray-400 mt-2">
                    Interactive diagram for a Frigate / AI Inference workflow.
                </p>
            </header>

            <main
                class="flex flex-col lg:flex-row items-center justify-center gap-8"
            >
                <!-- Left Side: The GPU Visualization -->
                <div class="w-full max-w-2xl lg:w-3/5 relative h-[350px]">
                    <div class="w-full h-full relative flex items-center justify-center">
                        <div class="relative w-[95%] h-[250px]">
                            <!-- Main Card Body -->
                            <div class="absolute top-[16px] left-0 w-full h-full bg-gray-800 rounded-lg shadow-2xl shadow-black/50 flex flex-col">
                                <!-- Data Path Overlay -->
                                <div id="path-overlay" class="path-overlay"></div>

                                <!-- IO Bracket -->
                                <div class="absolute left-0 top-0 w-3 h-[300px] bg-gray-600 rounded-l-lg io-bracket"></div>

                                <!-- PCIe Connector -->
                                <div
                                    id="pcie-connector"
                                    class="pcie-connector bottom-[-34px] left-[10%] w-[60%] h-[24px] z-10 flex items-center justify-center"
                                ></div>

                                <!-- Top part with components -->
                                <div class="flex-grow flex p-4 gap-4">
                                    <!-- Components Area -->
                                    <div class="flex-1 grid grid-cols-12 gap-2">
                                        <!-- NVDEC Section -->
                                        <div
                                            id="nvdec-section"
                                            class="col-span-4 flex flex-col justify-center items-center ml-2 gap-4"
                                        >
                                            <div
                                                id="nvdec-1"
                                                class="nvdec-block w-full h-16 rounded-lg bg-indigo-900/50 flex items-center justify-center p-[2px]"
                                                data-nvdec-index="0"
                                            >
                                                <span class="font-semibold text-xs text-indigo-200 text-center pointer-events-none">NVDEC 1</span>
                                            </div>
                                            <div
                                                id="nvdec-2"
                                                class="nvdec-block w-full h-16 rounded-lg bg-indigo-900/50 flex items-center justify-center p-[2px]"
                                                data-nvdec-index="1"
                                            >
                                                <span class="font-semibold text-xs text-indigo-200 text-center pointer-events-none">NVDEC 2</span>
                                            </div>
                                        </div>
                                        <!-- CUDA Cores Section -->
                                        <div
                                            id="cuda-section"
                                            class="col-span-8 bg-gray-900/50 rounded-lg p-3 flex items-center justify-center transition-all duration-300"
                                        >
                                            <div
                                                id="cuda-grid"
                                                class="grid grid-cols-25 gap-[6px] w-full h-full pointer-events-none"
                                            >
                                                <!-- JS Generated Cores -->
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <!-- Bottom part with fans (Fan Shroud) -->
                                <div
                                    id="fan-section"
                                    class="h-24 fan-shroud rounded-b-lg flex justify-end items-center px-8 gap-8"
                                >
                                    <div class="w-16 h-16 rounded-full fan flex items-center justify-center">
                                        <div class="w-12 h-12 rounded-full relative">
                                            <div class="fan-spinner" id="fan-1"></div>
                                        </div>
                                    </div>
                                    <div class="w-16 h-16 rounded-full fan flex items-center justify-center">
                                        <div class="w-12 h-12 rounded-full relative">
                                            <div class="fan-spinner" id="fan-2" style="animation-delay: -1s"></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Right Side: Controls and Explanations -->
                <div class="w-full max-w-xl lg:w-2/5">
                    <div class="bg-gray-800 rounded-2xl p-6">
                        <h2 class="text-xl font-bold mb-4">
                            Explore the Components
                        </h2>
                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-3 mb-6">
                            <button
                                id="btn-cuda"
                                class="w-full bg-teal-600 hover:bg-teal-500 transition-colors py-2 px-4 rounded-lg font-semibold"
                            >
                                CUDA Cores
                            </button>
                            <button
                                id="btn-nvdec"
                                class="w-full bg-indigo-600 hover:bg-indigo-500 transition-colors py-2 px-4 rounded-lg font-semibold"
                            >
                                NVDEC
                            </button>
                            <button
                                id="btn-pcie"
                                class="w-full bg-yellow-600 hover:bg-yellow-500 transition-colors py-2 px-4 rounded-lg font-semibold"
                            >
                                PCIe Connector
                            </button>
                            <button
                                id="btn-data-path"
                                class="w-full bg-cyan-600 hover:bg-cyan-500 transition-colors py-2 px-4 rounded-lg font-semibold"
                            >
                                ðŸ“Š Data Path
                            </button>
                        </div>
                        <div
                            id="explanation-box"
                            class="bg-gray-900/70 p-4 rounded-lg min-h-[220px] transition-all duration-300"
                        >
                            <h3
                                id="explanation-title"
                                class="text-lg font-bold text-gray-200 mb-2"
                            >
                                Select a component
                            </h3>
                            <p id="explanation-text" class="text-gray-300">
                                Click a button above or click directly on the
                                GPU components to learn about each part of the
                                AI video processing workflow.
                            </p>
                        </div>
                    </div>
                </div>
            </main>
        </div>

        <script>
            // --- DOM Element References ---
            const cudaGrid = document.getElementById("cuda-grid");
            const cudaSection = document.getElementById("cuda-section");
            const nvdecBlocks = [
                document.getElementById("nvdec-1"),
                document.getElementById("nvdec-2"),
            ];
            const nvdecSection = document.getElementById("nvdec-section");
            const pcieConnector = document.getElementById("pcie-connector");
            const fan1 = document.getElementById("fan-1");
            const fan2 = document.getElementById("fan-2");
            const pathOverlay = document.getElementById("path-overlay");

            const btnCuda = document.getElementById("btn-cuda");
            const btnNvdec = document.getElementById("btn-nvdec");
            const btnPcie = document.getElementById("btn-pcie");
            const btnDataPath = document.getElementById("btn-data-path");

            const explanationTitle = document.getElementById("explanation-title");
            const explanationText = document.getElementById("explanation-text");

            const NUM_CORES = 225;
            let animationTimeouts = [];
            let pathAnimationActive = false;

            // --- Utility Functions for Component Overlap Detection ---
            function getComponentBounds() {
                const overlayRect = pathOverlay.getBoundingClientRect();
                
                return [
                    {
                        name: 'nvdec1',
                        left: nvdecBlocks[0].getBoundingClientRect().left - overlayRect.left,
                        right: nvdecBlocks[0].getBoundingClientRect().right - overlayRect.left,
                        top: nvdecBlocks[0].getBoundingClientRect().top - overlayRect.top,
                        bottom: nvdecBlocks[0].getBoundingClientRect().bottom - overlayRect.top
                    },
                    {
                        name: 'nvdec2',
                        left: nvdecBlocks[1].getBoundingClientRect().left - overlayRect.left,
                        right: nvdecBlocks[1].getBoundingClientRect().right - overlayRect.left,
                        top: nvdecBlocks[1].getBoundingClientRect().top - overlayRect.top,
                        bottom: nvdecBlocks[1].getBoundingClientRect().bottom - overlayRect.top
                    },
                    {
                        name: 'cuda',
                        left: cudaSection.getBoundingClientRect().left - overlayRect.left,
                        right: cudaSection.getBoundingClientRect().right - overlayRect.left,
                        top: cudaSection.getBoundingClientRect().top - overlayRect.top,
                        bottom: cudaSection.getBoundingClientRect().bottom - overlayRect.top
                    },
                    {
                        name: 'pcie',
                        left: pcieConnector.getBoundingClientRect().left - overlayRect.left,
                        right: pcieConnector.getBoundingClientRect().right - overlayRect.left,
                        top: pcieConnector.getBoundingClientRect().top - overlayRect.top,
                        bottom: pcieConnector.getBoundingClientRect().bottom - overlayRect.top
                    }
                ];
            }

            function splitLineByComponents(x1, y1, x2, y2, isVertical, componentBounds) {
                const segments = [];
                const lineThickness = 3;
                
                if (isVertical) {
                    // For vertical lines, check y-axis intersections
                    const lineX = x1;
                    const startY = Math.min(y1, y2);
                    const endY = Math.max(y1, y2);
                    const isReversed = y1 > y2;
                    
                    // Find all intersections with components
                    const intersections = [];
                    componentBounds.forEach(comp => {
                        if (lineX >= comp.left - lineThickness/2 && lineX <= comp.right + lineThickness/2) {
                            if (comp.top < endY && comp.bottom > startY) {
                                intersections.push({
                                    start: Math.max(startY, comp.top),
                                    end: Math.min(endY, comp.bottom),
                                    component: comp.name
                                });
                            }
                        }
                    });
                    
                    // Sort intersections by start position
                    intersections.sort((a, b) => a.start - b.start);
                    
                    // Create segments between intersections
                    let currentY = startY;
                    
                    intersections.forEach(intersection => {
                        // Add visible segment before intersection
                        if (currentY < intersection.start) {
                            segments.push({
                                x: x1 - lineThickness/2,
                                y: currentY,
                                width: lineThickness,
                                height: intersection.start - currentY,
                                isVertical: true,
                                isReversed: isReversed,
                                visible: true
                            });
                        }
                        
                        // Add hidden segment for intersection
                        segments.push({
                            x: x1 - lineThickness/2,
                            y: intersection.start,
                            width: lineThickness,
                            height: intersection.end - intersection.start,
                            isVertical: true,
                            isReversed: isReversed,
                            visible: false
                        });
                        
                        currentY = intersection.end;
                    });
                    
                    // Add final visible segment
                    if (currentY < endY) {
                        segments.push({
                            x: x1 - lineThickness/2,
                            y: currentY,
                            width: lineThickness,
                            height: endY - currentY,
                            isVertical: true,
                            isReversed: isReversed,
                            visible: true
                        });
                    }
                    
                } else {
                    // For horizontal lines, check x-axis intersections
                    const lineY = y1;
                    const startX = Math.min(x1, x2);
                    const endX = Math.max(x1, x2);
                    const isReversed = x1 > x2;
                    
                    // Find all intersections with components
                    const intersections = [];
                    componentBounds.forEach(comp => {
                        if (lineY >= comp.top - lineThickness/2 && lineY <= comp.bottom + lineThickness/2) {
                            if (comp.left < endX && comp.right > startX) {
                                intersections.push({
                                    start: Math.max(startX, comp.left),
                                    end: Math.min(endX, comp.right),
                                    component: comp.name
                                });
                            }
                        }
                    });
                    
                    // Sort intersections by start position
                    intersections.sort((a, b) => a.start - b.start);
                    
                    // Create segments between intersections
                    let currentX = startX;
                    
                    intersections.forEach(intersection => {
                        // Add visible segment before intersection
                        if (currentX < intersection.start) {
                            segments.push({
                                x: currentX,
                                y: y1 - lineThickness/2,
                                width: intersection.start - currentX,
                                height: lineThickness,
                                isVertical: false,
                                isReversed: isReversed,
                                visible: true
                            });
                        }
                        
                        // Add hidden segment for intersection
                        segments.push({
                            x: intersection.start,
                            y: y1 - lineThickness/2,
                            width: intersection.end - intersection.start,
                            height: lineThickness,
                            isVertical: false,
                            isReversed: isReversed,
                            visible: false
                        });
                        
                        currentX = intersection.end;
                    });
                    
                    // Add final visible segment
                    if (currentX < endX) {
                        segments.push({
                            x: currentX,
                            y: y1 - lineThickness/2,
                            width: endX - currentX,
                            height: lineThickness,
                            isVertical: false,
                            isReversed: isReversed,
                            visible: true
                        });
                    }
                }
                
                // If no intersections found, return the full line as visible
                if (segments.length === 0) {
                    segments.push({
                        x: isVertical ? x1 - lineThickness/2 : Math.min(x1, x2),
                        y: isVertical ? Math.min(y1, y2) : y1 - lineThickness/2,
                        width: isVertical ? lineThickness : Math.abs(x2 - x1),
                        height: isVertical ? Math.abs(y2 - y1) : lineThickness,
                        isVertical: isVertical,
                        isReversed: isVertical ? y1 > y2 : x1 > x2,
                        visible: true
                    });
                }
                
                return segments;
            }

            // --- Fan Speed Control Functions ---
            function setFanSpeed(speed) {
                let duration;
                switch (speed) {
                    case "fast":
                        duration = "0.4s";
                        break;
                    case "medium":
                        duration = "1.2s";
                        break;
                    case "normal":
                    default:
                        duration = "2s";
                        break;
                }

                fan1.style.setProperty("--fan-duration", duration);
                fan2.style.setProperty("--fan-duration", duration);
            }

            // --- Content for Explanations ---
            const explanations = {
                cuda: {
                    title: "CUDA Cores: The AI Brains",
                    text: "These are thousands of small, efficient cores designed for parallel computing. In a Frigate workflow, after a video is decoded, the raw frames are sent here. The CUDA cores run the AI model (e.g., object detection) to find people, cars, etc. This is the heavy-lifting, computational part of the process.",
                },
                nvdec: {
                    title: "NVDEC: The Video Decoder",
                    text: "This is dedicated hardware for decoding compressed video. Frigate offloads the CPU-intensive task of decoding H.264/H.265 streams from cameras to NVDEC. This is extremely efficient and frees up the CPU and CUDA cores, allowing the GPU to handle many more camera streams.",
                },
                pcie: {
                    title: "PCIe Connector: The Data Highway",
                    text: "The PCIe x16 slot is the high-speed connection between the GPU and motherboard. In AI video processing, this carries massive amounts of data: video streams from cameras, decoded frames, AI model weights, and inference results. The PCIe 4.0 x16 connection provides up to 32 GB/s of bandwidth, crucial for real-time processing of multiple camera feeds.",
                },
                dataPath: {
                    title: "Data Flow Visualization",
                    text: "Watch how data flows through the GPU: 1) Video streams enter via PCIe â†’ 2) NVDEC 2 decodes the video â†’ 3) NVDEC 1 processes frames â†’ 4) CUDA cores perform AI inference â†’ 5) Results travel back through PCIe to the system. This organized path shows the efficient pipeline that makes real-time AI video processing possible.",
                },
                default: {
                    title: "Select a component",
                    text: "Click a button above or click directly on the GPU components to learn about each part of the AI video processing workflow.",
                },
            };

            function generateCudaCores() {
                cudaGrid.innerHTML = "";
                for (let i = 0; i < NUM_CORES; i++) {
                    const core = document.createElement("div");
                    core.classList.add("cuda-core", "rounded-sm");
                    cudaGrid.appendChild(core);
                }
            }

            function clearAllTimeouts() {
                animationTimeouts.forEach((timeout) => clearTimeout(timeout));
                animationTimeouts = [];
            }

            function clearPathVisualization() {
                pathOverlay.innerHTML = "";
                pathAnimationActive = false;
            }

            function resetAllHighlights() {
                clearAllTimeouts();
                clearPathVisualization();

                // Reset CUDA cores
                Array.from(cudaGrid.children).forEach((core) => {
                    core.classList.remove("highlight");
                });

                // Reset NVDEC blocks
                nvdecBlocks.forEach((block) =>
                    block.classList.remove("highlight"),
                );

                // Reset PCIe connector
                pcieConnector.classList.remove("highlight");

                // Reset fade effects
                cudaSection.classList.remove("component-fade");
                nvdecSection.classList.remove("component-fade");
                pcieConnector.classList.remove("component-fade");
            }

            function updateExplanation(key) {
                const explanation = explanations[key];
                explanationTitle.style.opacity = "0";
                explanationText.style.opacity = "0";

                setTimeout(() => {
                    explanationTitle.innerHTML = explanation.title;
                    explanationText.innerHTML = explanation.text;
                    explanationTitle.style.opacity = "1";
                    explanationText.style.opacity = "1";
                }, 150);
            }

            function staggerCudaHighlight() {
                return new Promise(resolve => {
                    const cores = Array.from(cudaGrid.children);
                    let lastCoreIndex = cores.length - 1;
                    let completedCores = 0;
                    
                    cores.forEach((core, index) => {
                        const timeout = setTimeout(() => {
                            core.classList.add("highlight");
                            completedCores++;
                            
                            if (completedCores >= cores.length) {
                                setTimeout(resolve, 200); // Small delay after last core is lit
                            }
                        }, index * 8);
                        animationTimeouts.push(timeout);
                    });
                });
            }

            function createPathElement(x, y, width, height, isVertical = false, isReversed = false, visible = true, pathOrder = 0) {
                const pathElement = document.createElement("div");
                const orientation = isVertical ? 'vertical' : 'horizontal';
                pathElement.className = `path-line ${orientation}${isReversed ? ' reverse' : ''}${!visible ? ' hidden-under-component' : ''}`;
                pathElement.style.left = `${x}px`;
                pathElement.style.top = `${y}px`;
                pathElement.style.width = `${width}px`;
                pathElement.style.height = `${height}px`;
                pathElement.dataset.pathOrder = pathOrder; // Add path order for proper sequencing
                return pathElement;
            }

            // Improved data path animation with sequential highlighting
            async function animateDataPath() {
                if (pathAnimationActive) return;
                pathAnimationActive = true;

                // Clear any existing paths
                pathOverlay.innerHTML = "";

                // Get component positions relative to the path overlay
                const overlayRect = pathOverlay.getBoundingClientRect();
                const pcieRect = pcieConnector.getBoundingClientRect();
                const nvdec2Rect = nvdecBlocks[1].getBoundingClientRect();
                const nvdec1Rect = nvdecBlocks[0].getBoundingClientRect();
                const cudaRect = cudaSection.getBoundingClientRect();

                // Calculate relative positions
                const pcieCenter = {
                    x: pcieRect.left - overlayRect.left + pcieRect.width / 2,
                    y: pcieRect.top - overlayRect.top + pcieRect.height / 2
                };

                const nvdec2Center = {
                    x: nvdec2Rect.left - overlayRect.left + nvdec2Rect.width / 2,
                    y: nvdec2Rect.top - overlayRect.top + nvdec2Rect.height / 2
                };

                const nvdec1Center = {
                    x: nvdec1Rect.left - overlayRect.left + nvdec1Rect.width / 2,
                    y: nvdec1Rect.top - overlayRect.top + nvdec1Rect.height / 2
                };

                const cudaCenter = {
                    x: cudaRect.left - overlayRect.left + cudaRect.width / 2,
                    y: cudaRect.top - overlayRect.top + cudaRect.height / 2
                };

                // Get component bounds for overlap detection
                const componentBounds = getComponentBounds();

                // Define the path points with 90-degree turns
                const pathPoints = [
                    { x: pcieCenter.x, y: pcieCenter.y, label: "PCIe In" },
                    { x: pcieCenter.x, y: pcieCenter.y - 40, label: "Turn 1" },
                    { x: nvdec2Center.x, y: pcieCenter.y - 40, label: "Turn 2" },
                    { x: nvdec2Center.x, y: nvdec2Center.y, label: "To NVDEC 2" },
                    { x: nvdec1Center.x, y: nvdec2Center.y, label: "NVDEC 2" },
                    { x: nvdec1Center.x, y: nvdec1Center.y, label: "NVDEC 1" },
                    { x: nvdec1Center.x + 98.5, y: nvdec1Center.y, label: "Turn 3" },
                    { x: nvdec1Center.x + 98.5, y: cudaCenter.y - 65, label: "Turn 4" },
                    { x: cudaCenter.x, y: cudaCenter.y, label: "CUDA Cores" },
                    { x: cudaCenter.x + 185, y: cudaCenter.y, label: "Turn 5" },
                    { x: cudaCenter.x + 185, y: cudaCenter.y + 88, label: "Turn 6" },
                    { x: pcieCenter.x + 20, y: cudaCenter.y + 88, label: "Turn 7" },
                    { x: pcieCenter.x + 20, y: pcieCenter.y, label: "PCIe Out" }
                ];

                // Create path segments with proper ordering
                const pathSegmentsByOrder = {};

                for (let i = 0; i < pathPoints.length - 1; i++) {
                    const start = pathPoints[i];
                    const end = pathPoints[i + 1];
                    
                    const isVertical = start.x === end.x;
                    const isReversed = isVertical ? start.y > end.y : start.x > end.x;
                    
                    // Split line segments based on component intersections
                    const segments = splitLineByComponents(start.x, start.y, end.x, end.y, isVertical, componentBounds);
                    
                    if (!pathSegmentsByOrder[i]) {
                        pathSegmentsByOrder[i] = [];
                    }

                    segments.forEach(segment => {
                        const pathElement = createPathElement(
                            segment.x, 
                            segment.y, 
                            segment.width, 
                            segment.height, 
                            segment.isVertical, 
                            segment.isReversed,
                            segment.visible,
                            i
                        );
                        pathOverlay.appendChild(pathElement);
                        
                        pathSegmentsByOrder[i].push({
                            element: pathElement,
                            visible: segment.visible
                        });
                    });
                }

                // Sequential component highlighting based on path progress
                const componentHighlights = [
                    { element: pcieConnector, segment: 0, action: 'highlight' },
                    { element: nvdecBlocks[1], segment: 3, action: 'highlight' },
                    { element: nvdecBlocks[0], segment: 5, action: 'highlight' },
                    { segment: 8, action: 'cuda-highlight' },
                    { element: pcieConnector, segment: 12, action: 'highlight' }
                ];

                // Animate segments and components sequentially
                for (let i = 0; i < Object.keys(pathSegmentsByOrder).length; i++) {
                    const segmentKey = i.toString();
                    const segments = pathSegmentsByOrder[i];
                    
                    // Animate path segments
                    segments.forEach(segmentInfo => {
                        if (segmentInfo.visible && !segmentInfo.element.classList.contains("hidden-under-component")) {
                            segmentInfo.element.classList.add("animate");
                        }
                    });

                    // Check if we need to highlight a component at this point
                    const componentToHighlight = componentHighlights.find(h => h.segment === i);
                    if (componentToHighlight) {
                        if (componentToHighlight.action === 'cuda-highlight') {
                            await staggerCudaHighlight();
                        } else if (componentToHighlight.element) {
                            componentToHighlight.element.classList.add("highlight");
                            await new Promise(resolve => {
                                setTimeout(() => {
                                    componentToHighlight.element.classList.remove("highlight");
                                    resolve();
                                }, 800);
                            });
                        }
                    } else {
                        // Wait for animation to complete before moving to next segment
                        await new Promise(resolve => setTimeout(resolve, 400));
                    }
                }

                // Final PCIe highlight
                pcieConnector.classList.add("highlight");
                setTimeout(() => {
                    pcieConnector.classList.remove("highlight");
                }, 800);

                pathAnimationActive = false;
            }

            function handleCudaClick() {
                resetAllHighlights();
                nvdecSection.classList.add("component-fade");
                pcieConnector.classList.add("component-fade");
                setTimeout(() => staggerCudaHighlight(), 100);
                updateExplanation("cuda");
                setFanSpeed("fast");
            }

            function handleNvdecClick(startIndex = 0) {
                resetAllHighlights();
                cudaSection.classList.add("component-fade");
                pcieConnector.classList.add("component-fade");

                const orderedBlocks =
                    startIndex === 0
                        ? [nvdecBlocks[0], nvdecBlocks[1]]
                        : [nvdecBlocks[1], nvdecBlocks[0]];

                orderedBlocks.forEach((block, index) => {
                    const timeout = setTimeout(() => {
                        block.classList.add("highlight");
                    }, index * 200);
                    animationTimeouts.push(timeout);
                });

                updateExplanation("nvdec");
                setFanSpeed("medium");
            }

            function handlePcieClick() {
                resetAllHighlights();
                cudaSection.classList.add("component-fade");
                nvdecSection.classList.add("component-fade");

                const timeout = setTimeout(() => {
                    pcieConnector.classList.add("highlight");
                }, 100);
                animationTimeouts.push(timeout);

                updateExplanation("pcie");
                setFanSpeed("normal");
            }

            function handleDataPathClick() {
                resetAllHighlights();
                updateExplanation("dataPath");
                setFanSpeed("fast");
                
                setTimeout(() => {
                    animateDataPath();
                }, 200);
            }

            function handleResetClick() {
                resetAllHighlights();
                updateExplanation("default");
                setFanSpeed("normal");
            }

            // --- Event Listeners ---
            btnCuda.addEventListener("click", handleCudaClick);
            btnNvdec.addEventListener("click", () => handleNvdecClick(0));
            btnPcie.addEventListener("click", handlePcieClick);
            btnDataPath.addEventListener("click", handleDataPathClick);

            // Direct component clicking
            cudaSection.addEventListener("click", handleCudaClick);
            pcieConnector.addEventListener("click", handlePcieClick);

            // Individual NVDEC block clicking with specific start index
            nvdecBlocks.forEach((block, index) => {
                block.addEventListener("click", () => handleNvdecClick(index));
            });

            // Click anywhere else to reset
            document.addEventListener("click", function (event) {
                const isInteractiveElement =
                    event.target.closest("#btn-cuda") ||
                    event.target.closest("#btn-nvdec") ||
                    event.target.closest("#btn-pcie") ||
                    event.target.closest("#btn-data-path") ||
                    event.target.closest("#cuda-section") ||
                    event.target.closest(".nvdec-block") ||
                    event.target.closest("#pcie-connector") ||
                    event.target.closest("#explanation-box");

                if (!isInteractiveElement) {
                    handleResetClick();
                }
            });

            // Prevent clicks on CUDA cores from bubbling up
            cudaGrid.addEventListener("click", function (event) {
                event.stopPropagation();
            });

            // --- Initialization ---
            window.onload = () => {
                generateCudaCores();
                updateExplanation("default");
                setFanSpeed("normal");

                // Add subtle entrance animation
                const main = document.querySelector("main");
                main.style.opacity = "0";
                main.style.transform = "translateY(20px)";

                setTimeout(() => {
                    main.style.transition = "all 0.8s cubic-bezier(0.23, 1, 0.32, 1)";
                    main.style.opacity = "1";
                    main.style.transform = "translateY(0)";
                }, 100);
            };
        </script>
    </body>
</html>